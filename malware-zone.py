#!/usr/bin/env python3

import yaml
import argparse
import os.path
import requests
import re
from datetime import datetime
import dns.resolver
import subprocess


def main():
    setVars()
    domains = parseLists()
    generateZone(domains)
    reloadZone()


def setVars():
    # Sets several global vars several functions access
    global args
    args = getArgs()

    global whitelist
    whitelist = getWhitelist()

    global lists
    lists = getLists()

    global zonefile
    if args.zonefile == "":
         zonefile = "/etc/bind/db.{}".format(args.zone)
    else:
        zonefile = args.zonefile

    # Create resolve object to use for DNS queries to host being configured
    global resolver
    resolver = dns.resolver.Resolver()
    resolver.nameservers = [args.resolver]
    resolver.timeout = 1
    resolver.lifetime = 1

 
def getArgs():
    parser = argparse.ArgumentParser(description='DNS RPZ Zone File Builder')
    parser.add_argument('-w', '--whitelist', help='Path to YAML formatted whitelist file', default='/etc/bind/whitelist.yml')
    parser.add_argument('--zonefile', help='Zone file name to create', default='')
    parser.add_argument('-z', '--zone', help='Name of RPZ zone', default='rpz.malware')
    parser.add_argument('-r', '--resolver', help='Resolver IP hosting domain', default='127.0.0.1')
    parser.add_argument('-e', '--email', help='Email for SOA [use dot instead of @ symbol]', default='rez.rankinrez.net')
    parser.add_argument('-n', '--nameserver', help='Nameserver name for the auth server in SOA.', default='localhost')
    return parser.parse_args()


def getWhitelist():
    whitelist = { "whitelist": {} }

    if os.path.isfile(args.whitelist):
        whitelist_file = open(args.whitelist, 'r')
        try:
            whitelist = yaml.safe_load(whitelist_file.read())
        except:
            print("WARNING: Could not load whitelist from YAML file {}".format(
                args.whitelist))

    return whitelist
    

def getLists():
    # Defines lists to parse and regex for filtering and extracting domain names.
    global regex_domain
    regex_domain = '^(127|0)\\.0\\.0\\.(0|1)[\\s\\t]+(?P<domain>([a-z0-9\\-_]+\\.)+[a-z][a-z0-9_-]*)$'
    global regex_no_comment
    regex_no_comment = '^#.*|^$'

    return [
        {'url': 'https://pgl.yoyo.org/as/serverlist.php?hostformat=nohtml&showintro=0', 'filter': regex_no_comment},
        {'url': 'http://winhelp2002.mvps.org/hosts.txt', 'regex': regex_domain, 'filter': regex_no_comment},
        {'url': 'https://adaway.org/hosts.txt', 'regex': regex_domain, 'filter': regex_no_comment},
        {'url': 'http://someonewhocares.org/hosts/zero/hosts', 'regex': regex_domain, 'filter': regex_no_comment},
        {'url': 'https://www.malwaredomainlist.com/hostslist/hosts.txt', 'regex': regex_domain, 'filter': regex_no_comment},

        #
        # adlists from pi-hole: https://github.com/pi-hole/pi-hole/blob/master/adlists.default
        #
        # The below list amalgamates several lists we used previously.
        # See `https://github.com/StevenBlack/hosts` for details
        # StevenBlack's list
        {'url': 'https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts', 'regex': regex_domain, 'filter': regex_no_comment},

        # Cameleon
        {'url': 'http://sysctl.org/cameleon/hosts', 'regex': regex_domain, 'filter': regex_no_comment},

        # Disconnect.me Tracking
        {'url': 'https://s3.amazonaws.com/lists.disconnect.me/simple_tracking.txt', 'filter': regex_no_comment},

        # Disconnect.me Ads
        {'url': 'https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt', 'filter': regex_no_comment},
    ]


def parseLists():
    domains = set([])

    for l in lists:
        print("\nList: {}".format(l['url']))
        data = downloadList(l['url'])
        for line in data.splitlines():
            domain = ''

            if 'filter' in l:
                m = re.match(l['filter'], line)
                if m:
                    continue

            if 'regex' in l:
                m = re.match(l['regex'], line)
                if m:
                    domain = m.group('domain')
            else:
                domain = line

            domain = domain.strip()

            if domainIsGood(domain):
                domains.add(domain)

    # Just do it my damn self:
    abuse_ch_resp = requests.get('https://urlhaus.abuse.ch/downloads/rpz/', timeout=(6, 20))
    if abuse_ch_resp.status_code == requests.codes.ok:
        for line in abuse_ch_resp.text.split("\n"):
            domain = line.split()[0]
            if not domain.startswith('$'):
                if not domain.startswith('@'):
                    if not domain.startswith(';'):
                        if domainIsGood(domain):
                            domains.add(domain)

    return domains


def downloadList(url):
    try:
        response = requests.get(url, timeout=10)
    except Exception as e:
        print("ERROR: Connection failed for {}: {}.".format(url, str(e)))
        return ""

    if response.status_code != requests.codes.ok:
        print("ERROR: {} returned for {}: {}".format(response.status_code, url, response.reason))
        return ""
    else:
        return response.text


def domainIsGood(domain):
    # Makes sure domain isn't empty and it is not on whitelist
    if domain == '':
        return False

    # Check against whitelist
    for whitelist_regex in whitelist['whitelist']:
        if re.match(whitelist_regex, domain):
            print("\tSkipping {0}, whitelisted".format(domain))
            return False

    return True


def generateZone(domains):
    serial = getNewSerial()

    outputzone = open(zonefile, 'w')

    outputzone.write("$TTL 86400\n")
    outputzone.write("@                        IN      SOA  {0}.    {1}. (\n".format(
        args.nameserver, args.email))
    outputzone.write("                                      {} ; serial\n".format(serial))
    outputzone.write("                                      86400      ; refresh\n")
    outputzone.write("                                      86400      ; retry\n")
    outputzone.write("                                      86400      ; expire\n")
    outputzone.write("                                      86400 )    ; minimum\n\n")
    outputzone.write("@ IN NS {}.\n\n".format(args.nameserver))

    for domain in domains:
        outputzone.write("{} IN CNAME .\n".format(domain))

    outputzone.write("\n")
    outputzone.close()

   
def getNewSerial():
    todays_date = datetime.today().strftime('%Y%m%d')
    try:
        soa_response = resolver.resolve(args.zone, "SOA")
        if soa_response.response.rcode() == 0:
            for item in soa_response.response.answer[0].items.keys():
                if type(item) == dns.rdtypes.ANY.SOA.SOA:
                    old_serial = str(item.serial)
            old_serial_date = old_serial[:-2]
            if old_serial_date == todays_date:
                # Same date, increment revision:
                revision = int(old_serial[-2:])
                revision += 1
                return "{}{:02d}".format(todays_date, revision)
    except Exception: 
      pass

    # Default just set revision to 00
    return "{}00".format(todays_date)


def reloadZone():
    cmd = ['rndc', 'reload', args.zone]
    r = subprocess.call(cmd)
    if r != 0:
        raise Exception('rndc failed with return code {}'.format(r))


if __name__ == '__main__':
    main()

